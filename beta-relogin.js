/*
  Beta Relogin Tester — Facebook (for your *own* accounts only)
  --------------------------------------------------------------
  v4 — Navigation-safe state loop to avoid "Execution context was destroyed".
        Waits for captcha/2FA/checkpoint/home and supports human mode.

  Outputs:
    ./out/cookies_<email>.json
    ./out/cookie_<email>.txt
    ./out/failure_<email>_<ts>.png
    ./out/failure_<email>_<ts>.html
*/

const fs = require('fs-extra');
const path = require('path');
const { authenticator } = require('otplib');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
puppeteer.use(StealthPlugin());

const argv = yargs(hideBin(process.argv))
  .option('email', { type: 'string' })
  .option('password', { type: 'string' })
  .option('totp', { type: 'string', describe: 'TOTP secret (base32). Optional if account has no 2FA.' })
  .option('creds', { type: 'string', describe: 'Path to creds file: email|password|totp' })
  .option('headless', { type: 'boolean', default: false })
  .option('proxy', { type: 'string' })
  .option('timeout', { type: 'number', default: 180000 })
  .option('human', { type: 'boolean', default: false, describe: 'Keep tab open on failure; keep polling for success.' })
  .option('slowmo', { type: 'number', default: 0, describe: 'Extra per-keystroke delay for debugging.' })
  .argv;

const OUT_DIR = path.resolve('./out');
fs.ensureDirSync(OUT_DIR);

function log(...args) { console.log(new Date().toISOString(), '-', ...args); }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function rand(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
function safe(s) { return String(s).replace(/[^a-z0-9_.-]+/gi, '_'); }

function parseCredsFile(p) {
  const lines = fs.readFileSync(p, 'utf8').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  return lines.map(line => {
    const [email, password, totp] = line.split('|');
    if (!email || !password) throw new Error(`Bad creds line: ${line}`);
    return { email, password, totp };
  });
}

async function saveCookies(page, email) {
  const cookies = await page.cookies();
  const jPath = path.join(OUT_DIR, `cookies_${safe(email)}.json`);
  await fs.writeJson(jPath, cookies, { spaces: 2 });

  const txtPath = path.join(OUT_DIR, `cookie_${safe(email)}.txt`);
  await fs.writeFile(txtPath, toNetscapeCookieFile(cookies));

  log('Cookies saved:', jPath, 'and', txtPath);
}

function toNetscapeCookieFile(cookies) {
  const header = [
    '# Netscape HTTP Cookie File',
    '# Generated by beta-relogin.js',
    '# <domain>\t<flag>\t<path>\t<secure>\t<expiration>\t<name>\t<value>'
  ].join('\n');
  const rows = cookies.map(c => {
    const domain = (c.domain || '').replace(/^\./, '.');
    const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
    const pathv = c.path || '/';
    const secure = c.secure ? 'TRUE' : 'FALSE';
    const expiry = c.expires ? Math.floor(c.expires) : Math.floor(Date.now()/1000) + 86400*30;
    return [domain, flag, pathv, secure, expiry, c.name, c.value].join('\t');
  });
  return header + '\n' + rows.join('\n') + '\n';
}

// --- Safe helpers that won't crash during navigations ---
async function safeEval(page, fn, fallback = null) {
  try { return await page.evaluate(fn); } catch { return fallback; }
}
async function hasSelector(page, sel, timeout = 0) {
  try {
    if (timeout > 0) {
      await page.waitForSelector(sel, { timeout });
      return true;
    }
    return !!(await page.$(sel));
  } catch { return false; }
}

async function ensureHomeLoaded(page) {
  // c_user cookie + a known surface
  const cookies = await page.cookies();
  const hasCUser = cookies.some(c => c.name === 'c_user' && c.value);
  if (!hasCUser) return false;
  try {
    await page.waitForSelector('[data-pagelet="Stories"], [role="feed"], [aria-label="Account"], [data-click="profile_icon"]', { timeout: 15000 });
    return true;
  } catch { return false; }
}

async function isTwoFactor(page) {
  if (await hasSelector(page, 'input[name="approvals_code"], #approvals_code')) return true;
  const txt = await safeEval(page, () => document.body?.innerText || '', '');
  return /two[\s-]?factor|login code|approval code|authentication app/i.test(txt);
}
async function isCheckpoint(page) {
  const url = page.url();
  if (/checkpoint/i.test(url)) return true;
  const txt = await safeEval(page, () => document.body?.innerText || '', '');
  return /confirm your identity|review recent login|checkpoint/i.test(txt);
}
async function isCaptcha(page) {
  const url = page.url();
  if (/captcha|recaptcha/i.test(url)) return true;
  const selectors = [
    'iframe[src*="recaptcha"]',
    'iframe[title*="captcha" i]',
    'div[class*="captcha" i]',
    'div[aria-label*="captcha" i]',
  ];
  for (const s of selectors) {
    if (await hasSelector(page, s)) return true;
  }
  return false;
}

async function waitForAny(page, untilMillis) {
  // Poll for a stable state; swallow exceptions from navigations
  while (Date.now() < untilMillis) {
    if (await ensureHomeLoaded(page)) return 'home';
    if (await isTwoFactor(page)) return '2fa';
    if (await isCaptcha(page)) return 'captcha';
    if (await isCheckpoint(page)) return 'checkpoint';

    // Recognize device-based login hop as "in progress"
    const url = page.url();
    if (/\/login\/device-based\/regular\/login/i.test(url)) {
      // nothing to do; it's normal redirect glue
    }

    await sleep(700);
  }
  return null;
}

async function clickLogin(page) {
  const loginSel = 'button[name="login"], #loginbutton, button[type="submit"]';
  const btn = await page.$(loginSel);
  if (btn) {
    await btn.click({ delay: rand(10, 40) });
  } else {
    await page.keyboard.press('Enter');
  }
}

async function typeSlow(page, selector, text) {
  await page.click(selector, { delay: rand(25, 60) });
  for (const ch of String(text)) {
    await page.keyboard.type(ch);
    if (argv.slowmo) await sleep(argv.slowmo);
    else await sleep(rand(8, 25));
  }
}

async function doLogin(page, { email, password, totp }, totalTimeoutMs) {
  const deadline = Date.now() + totalTimeoutMs;
  const gotoOpts = { waitUntil: 'domcontentloaded', timeout: Math.min(60000, totalTimeoutMs) };

  log('Navigating to login…');
  await page.goto('https://www.facebook.com/login', gotoOpts);

  // Early success (already logged)
  if (await ensureHomeLoaded(page)) { log('Already logged in.'); return true; }

  // Fill credentials
  await page.waitForSelector('input[name="email"], #email', { timeout: 30000 });
  await typeSlow(page, 'input[name="email"], #email', email);

  await page.waitForSelector('input[name="pass"], #pass', { timeout: 30000 });
  await typeSlow(page, 'input[name="pass"], #pass', password);

  // Click login, then let the redirects happen
  await clickLogin(page);

  // Wait for first outcome or keep polling even across navigations
  let state = await waitForAny(page, Date.now() + 60_000);
  log('Post-login state:', state || 'none yet');

  // Captcha → wait for human to solve
  if (state === 'captcha') {
    log('Captcha detected — please solve it manually. Waiting up to 5 minutes…');
    const end = Date.now() + 5 * 60 * 1000;
    while (Date.now() < end) {
      if (await ensureHomeLoaded(page)) { state = 'home'; break; }
      if (await isTwoFactor(page)) { state = '2fa'; break; }
      await sleep(1200);
    }
  }

  // 2FA (TOTP) branch
  if (state === '2fa' || await isTwoFactor(page)) {
    if (!totp) throw new Error('2FA required but no TOTP secret provided.');
    const code = authenticator.generate(totp);
    log('Submitting TOTP 2FA code…');
    // The field can re-render across navigations; try a few times
    for (let i = 0; i < 3; i++) {
      try {
        await page.type('input[name="approvals_code"], #approvals_code', code, { delay: rand(15, 35) });
        break;
      } catch { await sleep(800); }
    }

    // Continue / submit (handle multiple "remember" screens)
    const contSelectors = ['button[type="submit"]', '[id^="checkpointSubmitButton"]', 'button[name="submit[Continue]"]'];
    for (let step = 0; step < 4; step++) {
      let clicked = false;
      for (const s of contSelectors) {
        const el = await page.$(s);
        if (el) { await el.click({ delay: rand(10, 30) }); clicked = true; break; }
      }
      if (!clicked) break;
      await sleep(900);
    }

    try { await page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: 45000 }); } catch {}
    state = await waitForAny(page, Date.now() + 25_000) || state;
  }

  // Checkpoint (interactive)
  if (state === 'checkpoint' || await isCheckpoint(page)) {
    log('Checkpoint detected — review/continue in browser. Waiting up to 3 minutes…');
    const end = Date.now() + 3 * 60 * 1000;
    while (Date.now() < end) {
      if (await ensureHomeLoaded(page)) { state = 'home'; break; }
      await sleep(1000);
    }
  }

  // Final decision
  return await ensureHomeLoaded(page);
}

async function dumpFailureArtifacts(page, email) {
  try {
    const ts = Date.now();
    const base = path.join(OUT_DIR, `failure_${safe(email)}_${ts}`);
    await page.screenshot({ path: `${base}.png`, fullPage: true }).catch(()=>{});
    const html = await page.content().catch(() => '');
    await fs.writeFile(`${base}.html`, html).catch(()=>{});
    log('Saved failure artifacts:', `${base}.png`, `${base}.html`);
  } catch {}
}

async function runOne(browser, cred) {
  const page = await browser.newPage();

  // Lightweight debug hooks
  page.on('console', msg => log('[console]', msg.text()));
  page.on('pageerror', err => log('[pageerror]', err.message));
  page.on('response', res => {
    const u = res.url();
    if (/api\/graphql|checkpoint|captcha|login\/device-based/i.test(u)) {
      log('[response]', res.status(), u);
    }
  });

  await page.setViewport({ width: 1280, height: 800 });
  await page.setUserAgent(`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${rand(118,124)}.0.0.0 Safari/537.36`);
  page.setDefaultNavigationTimeout(120000);

  try {
    const ok = await doLogin(page, cred, argv.timeout);
    if (!ok) throw new Error('Login did not reach home (Stories/feed).');
    await saveCookies(page, cred.email);
    if (!argv.human) await page.close();
    return true;
  } catch (e) {
    log(`[${cred.email}] FAILED:`, e.message);
    await dumpFailureArtifacts(page, cred.email);
    if (argv.human) {
      log('HUMAN MODE: keeping tab open for manual rescue. I will poll for 10 minutes and save cookies if you reach home.');
      const end = Date.now() + 10 * 60 * 1000;
      while (!page.isClosed() && Date.now() < end) {
        if (await ensureHomeLoaded(page)) { await saveCookies(page, cred.email); break; }
        await sleep(1500);
      }
    }
    if (!page.isClosed()) await page.close();
    return false;
  }
}

(async () => {
  const args = [
    '--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage',
    '--lang=en-US,en', '--window-size=1280,800'
  ];
  if (argv.proxy) args.push(`--proxy-server=${argv.proxy}`);

  const browser = await puppeteer.launch({ headless: argv.headless, args, defaultViewport: null });

  let creds = [];
  if (argv.creds) creds = parseCredsFile(argv.creds);
  else if (argv.email && argv.password) creds = [{ email: argv.email, password: argv.password, totp: argv.totp }];
  else throw new Error('Provide --creds file or --email and --password');

  let allOk = true;
  for (const c of creds) {
    log('=== Starting login for', c.email, '===');
    const ok = await runOne(browser, c);
    allOk = allOk && ok;
  }

  await browser.close();
  process.exit(allOk ? 0 : 1);
})();
