/*
  Beta Relogin Tester — Facebook (for your *own* accounts only)
  --------------------------------------------------------------
  v3 — Robust waits for CAPTCHA/2FA/Checkpoint; interactive human mode; better logs & screenshots.

  Usage:
    npm i puppeteer-extra puppeteer-extra-plugin-stealth otplib yargs fs-extra
    node beta-relogin.js --creds=./accounts.txt --headless=false --human=true
    # or single account:
    node beta-relogin.js --email="you@example.com" --password="p@ss" --totp="BASE32" --headless=false --human=true

  Outputs:
    ./out/cookies_<email>.json
    ./out/cookie_<email>.txt
    ./out/failure_<email>_<timestamp>.png (on failures)
*/

const fs = require('fs-extra');
const path = require('path');
const { authenticator } = require('otplib');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');
puppeteer.use(StealthPlugin());

const argv = yargs(hideBin(process.argv))
  .option('email', { type: 'string' })
  .option('password', { type: 'string' })
  .option('totp', { type: 'string', describe: 'TOTP secret (base32). Optional if account has no 2FA.' })
  .option('creds', { type: 'string', describe: 'Path to creds file: email|password|totp' })
  .option('headless', { type: 'boolean', default: false })
  .option('proxy', { type: 'string', describe: 'http://user:pass@host:port (optional)' })
  .option('timeout', { type: 'number', default: 120000 })
  .option('human', { type: 'boolean', default: false, describe: 'Keep tab open on failure; wait for manual solving.' })
  .option('slowmo', { type: 'number', default: 0, describe: 'Slow down operations (ms) for debugging (Puppeteer slowMo-like via delays).' })
  .argv;

const OUT_DIR = path.resolve('./out');
fs.ensureDirSync(OUT_DIR);

function log(...args) { console.log(new Date().toISOString(), '-', ...args); }
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function rand(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a; }
function safe(s) { return String(s).replace(/[^a-z0-9_.-]+/gi, '_'); }

function parseCredsFile(p) {
  const lines = fs.readFileSync(p, 'utf8').split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  return lines.map(line => {
    const [email, password, totp] = line.split('|');
    if (!email || !password) throw new Error(`Bad creds line: ${line}`);
    return { email, password, totp };
  });
}

async function saveCookies(page, email) {
  const cookies = await page.cookies();
  const jPath = path.join(OUT_DIR, `cookies_${safe(email)}.json`);
  await fs.writeJson(jPath, cookies, { spaces: 2 });

  const txtPath = path.join(OUT_DIR, `cookie_${safe(email)}.txt`);
  await fs.writeFile(txtPath, toNetscapeCookieFile(cookies));

  log('Cookies saved:', jPath, 'and', txtPath);
}

function toNetscapeCookieFile(cookies) {
  const header = [
    '# Netscape HTTP Cookie File',
    '# Generated by beta-relogin.js',
    '# <domain>\t<flag>\t<path>\t<secure>\t<expiration>\t<name>\t<value>'
  ].join('\n');
  const rows = cookies.map(c => {
    const domain = (c.domain || '').replace(/^\./, '.');
    const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
    const pathv = c.path || '/';
    const secure = c.secure ? 'TRUE' : 'FALSE';
    const expiry = c.expires ? Math.floor(c.expires) : Math.floor(Date.now()/1000) + 86400*30;
    return [domain, flag, pathv, secure, expiry, c.name, c.value].join('\t');
  });
  return header + '\n' + rows.join('\n') + '\n';
}

async function ensureHomeLoaded(page) {
  const cookies = await page.cookies();
  const hasCUser = cookies.some(c => c.name === 'c_user' && c.value);
  if (!hasCUser) return false;
  try {
    await page.waitForSelector('[data-pagelet="Stories"], [role="feed"], [aria-label="Account"], [data-click="profile_icon"]', { timeout: 15000 });
    return true;
  } catch { return false; }
}

async function isTwoFactor(page) {
  if (await page.$('input[name="approvals_code"], #approvals_code')) return true;
  const txt = await page.evaluate(() => document.body?.innerText || '');
  return /two[\s-]?factor|login code|approval code|authentication app/i.test(txt);
}

async function isCheckpoint(page) {
  const url = page.url();
  if (/checkpoint/i.test(url)) return true;
  const txt = await page.evaluate(() => document.body?.innerText || '');
  return /confirm your identity|review recent login|checkpoint/i.test(txt);
}

async function isCaptcha(page) {
  const url = page.url();
  if (/captcha|recaptcha/i.test(url)) return true;
  const selectors = [
    'iframe[src*="recaptcha"]',
    'iframe[title*="captcha" i]',
    'div[class*="captcha" i]',
    'div[aria-label*="captcha" i]',
  ];
  for (const s of selectors) {
    if (await page.$(s)) return true;
  }
  return false;
}

async function waitForAny(page, deadlineMs) {
  // Poll for a state transition: home / 2fa / captcha / checkpoint
  while (Date.now() < deadlineMs) {
    if (await ensureHomeLoaded(page)) return 'home';
    if (await isTwoFactor(page)) return '2fa';
    if (await isCaptcha(page)) return 'captcha';
    if (await isCheckpoint(page)) return 'checkpoint';
    await sleep(600);
  }
  return null;
}

async function clickLogin(page) {
  const loginSel = 'button[name="login"], #loginbutton, button[type="submit"]';
  const btn = await page.$(loginSel);
  if (btn) {
    await btn.click({ delay: rand(10, 40) });
  } else {
    await page.keyboard.press('Enter');
  }
}

async function typeSlow(page, selector, text) {
  await page.click(selector);
  for (const ch of String(text)) {
    await page.keyboard.type(ch);
    if (argv.slowmo) await sleep(argv.slowmo);
    else await sleep(rand(10, 30));
  }
}

async function doLogin(page, { email, password, totp }, totalTimeoutMs) {
  const deadline = Date.now() + totalTimeoutMs;
  const gotoOpts = { waitUntil: 'domcontentloaded', timeout: Math.min(60000, totalTimeoutMs) };

  log('Navigating to login…');
  await page.goto('https://www.facebook.com/login', gotoOpts);

  // Early success check
  if (await ensureHomeLoaded(page)) { log('Already logged in.'); return true; }

  // Fill credentials
  await page.waitForSelector('input[name="email"], #email', { timeout: 30000 });
  await typeSlow(page, 'input[name="email"], #email', email);

  await page.waitForSelector('input[name="pass"], #pass', { timeout: 30000 });
  await typeSlow(page, 'input[name="pass"], #pass', password);

  // Click login
  await clickLogin(page);

  // Give the page time to route. DO NOT exit early.
  let state = await waitForAny(page, Date.now() + 45_000);
  log('Post-login state:', state || 'none yet');

  // If captcha: wait generously for manual solving
  if (state === 'captcha') {
    log('Captcha detected — please solve it manually in the visible browser.\nI will wait up to 5 minutes, then continue.');
    const end = Date.now() + 5 * 60 * 1000;
    while (Date.now() < end) {
      if (await ensureHomeLoaded(page)) { state = 'home'; break; }
      if (await isTwoFactor(page)) { state = '2fa'; break; }
      await sleep(1200);
    }
  }

  // 2FA branch (TOTP)
  if (state === '2fa' || await isTwoFactor(page)) {
    if (!totp) throw new Error('2FA required but no TOTP secret provided.');
    const code = authenticator.generate(totp);
    log('Submitting TOTP 2FA code…');
    await page.type('input[name="approvals_code"], #approvals_code', code, { delay: rand(15, 35) });

    // Continue / submit
    const contSelectors = ['button[type="submit"]', '[id^="checkpointSubmitButton"]', 'button[name="submit[Continue]"]'];
    for (const s of contSelectors) {
      const el = await page.$(s);
      if (el) { await el.click({ delay: rand(10, 30) }); break; }
    }

    // “Remember this browser” screens (0–3)
    for (let i = 0; i < 3; i++) {
      const next = await page.waitForSelector('button[type="submit"], [id^="checkpointSubmitButton"]', { timeout: 8000 }).then(() => true).catch(() => false);
      if (!next) break;
      const el = await page.$('button[type="submit"], [id^="checkpointSubmitButton"]');
      if (el) await el.click({ delay: rand(10, 30) });
      await sleep(800);
    }

    try { await page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: 45000 }); } catch {}
    state = await waitForAny(page, Date.now() + 20_000) || state;
  }

  // Checkpoint (basic interactive handling)
  if (state === 'checkpoint' || await isCheckpoint(page)) {
    log('Checkpoint flow detected — review/continue in browser. Waiting up to 3 minutes…');
    const end = Date.now() + 3 * 60 * 1000;
    while (Date.now() < end) {
      if (await ensureHomeLoaded(page)) { state = 'home'; break; }
      await sleep(1000);
    }
  }

  // Final success check
  return await ensureHomeLoaded(page);
}

async function runOne(browser, cred) {
  const page = await browser.newPage();

  // Helpful listeners for debugging
  page.on('console', msg => log('[console]', msg.text()));
  page.on('pageerror', err => log('[pageerror]', err.message));
  page.on('response', res => {
    const url = res.url();
    if (/api\/graphql|checkpoint|captcha|login/i.test(url)) {
      log('[response]', res.status(), url);
    }
  });

  await page.setViewport({ width: 1280, height: 800 });
  await page.setUserAgent(`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/${rand(118,124)}.0.0.0 Safari/537.36`);
  page.setDefaultNavigationTimeout(120000);

  try {
    const ok = await doLogin(page, cred, argv.timeout);
    if (!ok) throw new Error('Login did not reach home (Stories/feed).');
    await saveCookies(page, cred.email);
    if (!argv.human) await page.close();
    return true;
  } catch (e) {
    log(`[${cred.email}] FAILED:`, e.message);
    try {
      const shot = path.join(OUT_DIR, `failure_${safe(cred.email)}_${Date.now()}.png`);
      await page.screenshot({ path: shot, fullPage: true }).catch(()=>{});
      log('Saved failure screenshot:', shot);
    } catch {}
    if (argv.human) {
      log('HUMAN MODE: keeping the page open for manual resolution. Close the tab when done; I will keep polling for success for up to 10 minutes.');
      const end = Date.now() + 10 * 60 * 1000;
      while (!page.isClosed() && Date.now() < end) {
        if (await ensureHomeLoaded(page)) { await saveCookies(page, cred.email); break; }
        await sleep(1500);
      }
    }
    if (!page.isClosed()) await page.close();
    return false;
  }
}

(async () => {
  const launchArgs = [
    '--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage',
    '--lang=en-US,en', '--window-size=1280,800'
  ];
  if (argv.proxy) launchArgs.push(`--proxy-server=${argv.proxy}`);

  const browser = await puppeteer.launch({ headless: argv.headless, args: launchArgs, defaultViewport: null });

  let creds = [];
  if (argv.creds) creds = parseCredsFile(argv.creds);
  else if (argv.email && argv.password) creds = [{ email: argv.email, password: argv.password, totp: argv.totp }];
  else throw new Error('Provide --creds file or --email and --password');

  let allOk = true;
  for (const c of creds) {
    log('=== Starting login for', c.email, '===');
    const ok = await runOne(browser, c);
    allOk = allOk && ok;
  }

  await browser.close();
  process.exit(allOk ? 0 : 1);
})();
